# Knapsack
Các vấn đề knapsack thường liên quan đến việc điền các mục vào một container - thường có sức chứa cố định - để tối ưu hóa hoặc đếm một số lượng nào đó. Có hai loại chính của vấn đề napsack:
- Mỗi mục bao gồm (trọng lượng, giá trị)
- Mỗi mục bao gồm (trọng lượng)

![image](https://github.com/HieuHuyNguyenzz/CompetitiveProgramming/assets/135397654/a999cf39-7b0f-4065-9830-ff06ddc6ce53)

Dưới đây là hai trong số những vấn đề knapsack truyền thống nhất:
- Knapsack Problem (vấn đề knapsack): Đây là vấn đề cơ bản nhất, trong đó mỗi mục có một trọng lượng và giá trị riêng, và mục tiêu là chọn các mục sao cho tổng trọng lượng không vượt quá sức chứa của napsack (container) và tổng giá trị được tối đa hóa.
- Subset Sum Problem (vấn đề tổng tập con): Trong vấn đề này, mỗi mục chỉ có trọng lượng và không có giá trị. Mục tiêu là chọn một tập con các mục sao cho tổng trọng lượng bằng một số xác định hoặc tồn tại tập con có tổng trọng lượng bằng số xác định.
Những vấn đề knapsack trên đây là những ví dụ phổ biến, nhưng thường xuất hiện trong các biến thể và dạng khác nhau.

## 1. Dạng nguyên thủy
_Bài toán_: Một cái túi với sức chứa C là một số nguyên, và n đồ vật khác nhau, mỗi vật có trọng lượng và giá trị là một số nguyên. Nhiệm vụ là chọn một tập con các đối tượng sao cho giá trị của chúng là lớn nhất, nhưng tổng trọng lượng của chúng không vượt quá sức chứa của cái túi. 

Input: Số nguyên C biểu diễn khả năng chứa của cái túi và số nguyên n biểu diễn số lượng đối tượng. Sau đó sẽ là n đối tượng, mỗi đối tượng gồm giá trị (vi) và trọng lượng (wi).

Output: tổng giá trị lớn nhất có thể lấy được


Bài toán này có thể được giải sử dụng kỹ thuật đệ quy, nhánh cận tuy nhiên độ phức tạp sẽ là rất lớn khi tăng số đồ vật, có thể lên đến O($a^n$), trong đó a là số đồ vật được chọn.

Do vậy cách giải sử dụng quy hoạch động là cách giải tốt hơn nhiều khi có thể giải bài toán trong O(n*C).

Gọi DP[i][j] là tổng giá trị lớn nhất của các đồ vật lấy được khi chọn trong các đồ vật từ 1 đến i và giới hạn tổng trọng lượng của chúng là j.Kết quả của bài toán là tổng giá trị lớn nhất chọn được trong 
n vật với giới hạn trọng lượng là C, sẽ chính là dp[n][C]. Xét đồ vật thứ i, và giới hạn trọng lượng hiện tại là j, ta có hai phương án để lựa chọn:
- Nếu vật thứ i không được chọn vào phương án tối ưu, thì kết quả tối ưu sẽ được chọn trong (i−1) đồ vật trước đó với giới hạn trọng lượng vẫn là j.
- Nếu vật thứ i được chọn vào phương án tối ưu, thì tải trọng còn lại có thể sử dụng là (j−wi) cho (i−1) đồ vật phía trước, và ta được thêm giá trị vi của vật thứ i. Dĩ nhiên, trường hợp này chỉ xét đến khi 
j≥w.

Do đó ta có công thức truy hồi như sau:

Mã giả:
```
procedure KNAPSACK(capacity C, items n, values V, weights W)
  best new int[n + 1][C + 1]
  fill best with -1
  best[0][C] = 0
  for i from 0 to n - 1 do
    for j from 0 to C do
      if j ≥ W[i] then
        best[i + 1][j] max(best[i][j]; best[i][j - W[i]] + V[i])
  return best
```

## 2. Biến thể
