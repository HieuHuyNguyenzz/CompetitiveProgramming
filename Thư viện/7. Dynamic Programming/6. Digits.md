## DP Digits
DP digit là một dạng bài tập trong quy hoạch động có dạng có bao nhiêu số trong một khoảng nào đó thỏa mãn một điều kiện nào đó. Bài toán có thể được nhận biết như sau:
 
Bài toán: Có bao nhiêu số x nằm trong khoảng từ a đến b, với chứ cái d xuất hiện đúng k lần trong x? 

Bài toán này có rất nhiều cách giải như ngây thơ, sử dụng các định lý toán học,...

## 1. Cách làm ngây thơ
Dễ thấy cách làm hiển nhiên nhất cho bài toán là loop từ a đến b và kiểm tra từng số để tìm ra số các số thỏa mãn. Tuy nhiên cách giải này thường không tối ưu do các bài toán dạng này
thường cho a và b rất lớn (Khoảng $10^18$). Do đó cách làm này thường không đảm bảo được về mặt thời gian.

## 2. DP digit
Trong cách làm quy hoạch động, thay vì đếm các số thỏa mãn, chúng ta sẽ tập chung vào việc tạo ra các số x thỏa mãn yêu cầu đề bài. Lúc này chúng ta sẽ coi một số là dãy các số. 

Ban đầu xâu này rỗng, chúng ta sẽ thêm dần các số từ 1 đến 9 vào xâu theo thứ tự từ trái sang phải một cách đệ quy. Tuy nhiên quá trình thêm số này cần phải được đảm bảo số được tạo ra không thể lớn hơn b.

Khi đã thêm được $pos-1$ số trong xâu, chúng ta có thể đoán được số cần phải thêm vào vị trí $pos$. Đặt xâu đang tạo là s, ta có:

$$ a[1] \leqslant s[1] \leqslant b[1] $$

$$ a[i..pos-1] = s[i..pos-1]: a[pos] \leqslant s[pos] $$

$$  s[i..pos-1] \leqslant b[i..pos-1]: b[pos] \geqslant s[pos] $$

Nếu chưa tạo hết xâu s mà các số đã tạo thỏa mãn điều kiện của đề bài thì chúng ta sẽ không cần tiếp tục đệ quy nữa. 

Khi đã tạo được một đoạn số thỏa mãn chỉ chúng ta sẽ chỉ cần tăng biến đếm lên +1.

## 3. Cài đặt
Chúng ta sẽ sử dụng phương pháp đệ quy để sinh ra chuỗi số thỏa mãn. Sử dụng 3 tham số như sau:
- pos: vị trí đang xét
- cnt: biến đếm
- f: số được tạo ra có nhỏ hơn b?

Gọi đệ quy hoặc loop từ dp[0][0][0], với dp[pos][cnt][f] là trạng thái của bài toán, tương đương với số số thỏa mãn ở vị trí này.

## 4. Ví dụ
Ta có solution cho bài toán trên như sau:
```cpp
#include <bits/stdc++.h>
using namespace std;

vector<int> num;
int a, b, d, k;
int DP[12][12][2];

int call(int pos, int cnt, int f){
    if(cnt > k) return 0;
    if(pos == num.size()){
        if(cnt == k) return 1;
        return 0;
    }
    if(DP[pos][cnt][f] != -1) return DP[pos][cnt][f];
    int res = 0;
    int LMT;
    if(f == 0){
        /// kiểm tra nếu tiền tố xâu đang tạo khớp với tương ứng ở xâu b
        LMT = num[pos];
    } else {
        LMT = 9;
    }
    for(int dgt = 0; dgt<=LMT; dgt++){
        int nf = f;
        int ncnt = cnt;
        if(f == 0 && dgt < LMT) nf = 1; 
        if(dgt == d) ncnt++;
        if(ncnt <= k) res += call(pos+1, ncnt, nf);
    }
    return DP[pos][cnt][f] = res;
}
int solve(int b){
    num.clear();
    while(b>0){
        num.push_back(b%10);
        b/=10;
    }
    reverse(num.begin(), num.end());
    memset(DP, -1, sizeof(DP));
    int res = call(0, 0, 0);
    return res;
}

int main () {
    cin >> a >> b >> d >> k;
    int res = solve(b) - solve(a-1);
    cout << res << endl;
    return 0;
}
```
Thay vì phức tạp như phần 2 ở trên, thuật toán sẽ lấy số số đếm được từ 0 -> b trừ đi số số thỏa mãn từ 0 -> a-1.
